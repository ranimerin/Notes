String functions in Python: sequences of characters enclosed in quotes,
immutable and they are one of the most commonly used data types.
first ="Data"

find -returns -1 if not found
index- returns error if not found
count
replace(old,new)
split-by default space
strip-removes trailing and leading spaces
startswith
endswith
upper
lower

List:ordered,heterogenous,mutable,duplicates,[],slicer,indexing,*
len()
count()
index()
append()
insert()
extend()
remove()
pop()
join()
reverse()
sort()

list1 = [3, 1, 4, 2]
list1.sort()            # Sort ascending
list1.reverse()         # Reverse order
print(len(list1))       # Length of list
print(list1.count(3))   # Count occurrences of 3
print(list1.index(4))   # Find index of 

words= ["Data", "Engineering", "is", "awesome"]
sentence = " ".join(words)
print(sentence)
# Output: Data Engineering is awesome

# removeitems
nums.remove(20)        # Removes first occurrence of 20
popped = nums.pop()    # Removes and returns last item
popped = nums.pop(i)    # Removes element at index i
del nums[0]            # Deletes item at index 0

difference between append and extend
The main difference is that append() adds its argument as a single element to the list, 
while extend() adds each element of an iterable (like another list or a tuple) individually to the list

l1=["abc","def"]
l1.extend("ghi")
print(l1)
['abc', 'def', 'g', 'h', 'i']

l1=["abc","def"]
l1.extend(["ghi","jkl"])
print(l1)
['abc', 'def', 'ghi', 'jkl']

l1=["abc","def"]
l1.append(["ghi","jkl"])
print(l1)
['abc', 'def', ['ghi', 'jkl']]

l1=["abc","def"]
l1.append("ghi")
print(l1)
['abc', 'def', 'ghi']

List Comprehension:provides a concise and efficient way to create lists using a single line of code.
List comprehensions are ideal for scenarios where you need to:
Transform data from an existing iterable.
Filter elements based on a condition.
Improve performance and readability compared to equivalent for loops for simple operations. 
s=[x**2 for x in range(5)]


Dictionary:mutable,unordered,key-value pairs,{}. Keys must be unique and 
immutable (like strings, numbers, or tuples), values can be any type
Accessing Values by Key:print(ipl_teams["CSK"])  
Adding or updating:ipl_teams["RR"] = "Rajasthan Royals"  
Removing:ipl_teams.pop("SRH")          
        del ipl_teams["RR"]  
print(ipl_teams.keys())         
print(ipl_teams.values()) 

Tuple:ordered, immutable collection of elements,heterogeneous elements,duplicate,().
It’s like a list, but you can’t change it after creation.

# Basic tuple
colors = ("red", "green", "blue")
# Tuple with mixed data types
info= ("Ankit", 30, "Data Engineer")
# Single-element tuple (comma is important!)
single = ("hello",)
If you don’t put comma then it will be treated as normal variable , int , str etc

# Packing
person = ("Rohit", 35, "Mumbai")
# Unpacking
name, age, city = person
print(name)  # Rohit
print(city)  # Mumbai

list1 = [1, 2, 3]
tuple1 = tuple(list1)     # Convert list to tuple
tuple2 = (4, 5, 6)
list2 = list(tuple2)      # Convert tuple to list

Set:unordered, mutable collection of unique elements,{},heterogeneous,no duplicates
data= {1, 2, 2, 3}
print(data)  # Output: {1, 2, 3}

data= {1, 2}
data.add(3)
data.remove(2)      # Removes 2; error if not found
data.discard(5)     # No error if5 is not found

a= {1, 2, 3}
b= {3, 4, 5}
print(a.union(b))        # {1, 2, 3, 4, 5}
print(a.intersection(b)) # {3}
print(a.difference(b))   # {1, 2}

Symmetric difference: elements in either set1 or set2 but not both
